#include "ir_receiver.h"
#include <util/delay.h>
#include "sys/clock.h"
#include "sys/etimer.h" //contiki event timer library
#include "contiki.h"
#include "hexabus_config.h"
#include "value_broadcast.h"
#include "hexonoff.h"

#if IR_RECEIVER_DEBUG
#include <stdio.h>
#define PRINTF(...) printf(__VA_ARGS__)
#else
#define PRINTF(...)
#endif

static uint32_t ir_time = 0;
static uint32_t ir_time_since_last = 0;
static uint8_t ir_data[4] = {0,0,0,0};
static uint8_t ir_state = 0;
static uint8_t ir_edge_dir = 0;
static uint8_t ir_repeat = 0;
static uint8_t ir_bit = 0;
static uint8_t ir_byte = 0;
static uint8_t ir_last_data[4];

void ir_receiver_init() {

    //set_outputs(128);
    EICRA |= (1<<ISC21 );
    EIMSK |= (1<<INT2 );

    TCCR0A |= (1<<WGM01);
    TIMSK0 |= (1<<OCIE0A);
    OCR0A=COMP_VAL;
    TCCR0B |= ((1<<CS00));

    process_start(&ir_receiver_process, NULL);
    sei();
}

void ir_receiver_reset() {
    ir_data[0] = 0;
    ir_data[1] = 0;
    ir_data[2] = 0;
    ir_data[3] = 0;
    ir_state = 0;
    EICRA &= ~((1<<ISC21)|(1<<ISC20));
    EICRA |= (1<<ISC21);
    ir_edge_dir = 0;
}

uint32_t ir_get_last_command() {
#if IR_RECEIVER_RAW_MODE
    return *(uint32_t*) ir_last_data;
#else
    switch(*(uint32_t*) ir_last_data) {
        case IR0:
            return 1<<0;
            break;
        case IR1:
            return 1<<1;
            break;
        case IR2:
            return 1<<2;
            break;
        case IR3:
            return 1<<3
            break;
        case IR4:
            return 1<<4;
            break;
        case IR5:
            return 1<<5;
            break;
        case IR6:
            return 1<<6;
            break;
        case IR7:
            return 1<<7;
            break;
        case IR8:
            return 1<<8;
            break;
        case IR9:
            return 1<<9;
            break;
        case IR10:
            return 1<<10;
            break;
        case IR11:
            return 1<<11;
            break;
        case IR12:
            return 1<<12;
            break;
        case IR13:
            return 1<<13;
            break;
        case IR14:
            return 1<<14;
            break;
        case IR15:
            return 1<<15;
            break;
        case IR16:
            return 1<<16;
            break;
        case IR17:
            return 1<<17;
            break;
        case IR18:
            return 1<<18;
            break;
        case IR19:
            return 1<<19;
            break;
        case IR20:
            return 1<<20;
            break;
        case IR21:
            return 1<<21;
            break;
        case IR22:
            return 1<<22;
            break;
        case IR23:
            return 1<<23;
            break;
        case IR24:
            return 1<<24;
            break;
        case IR25:
            return 1<<25;
            break;
        case IR26:
            return 1<<26;
            break;
        case IR27:
            return 1<<27;
            break;
        case IR28:
            return 1<<28;
            break;
        case IR29:
            return 1<<29;
            break;
        case IR30:
            return 1<<30;
            break;
        case IR31:
            return 1<<31;
            break;
}

PROCESS(ir_receiver_process, "Listen for IR commands");

PROCESS_THREAD(ir_receiver_process, ev, data) {

    PROCESS_BEGIN();

    while(1) {
        PROCESS_WAIT_EVENT();

        if(ev == PROCESS_EVENT_POLL) {
            if(ir_repeat) {
                PRINTF("Got repeat signal %d \n", ir_time_since_last);
                ir_repeat = 0;
            } else {
                PRINTF("Got new command %d,%d,%d,%d!\n", ir_last_data[0],ir_last_data[1],ir_last_data[2],ir_last_data[3]);
            }
            broadcast_value(30);
        }
    }

    PROCESS_END();
}

ISR(INT2_vect) {
    toggle_outputs(128);
    EIMSK &= ~(1<<INT2);

    ir_time_since_last = ir_time;
    ir_time = 0;
    TCNT0 = 0;

    switch(ir_state) {
        case 0:                  //Waiting for AGC burst
            if(!ir_edge_dir) {   // Beginning of possible burst
                EICRA |= ((1<<ISC21)|(1<<ISC20));
                ir_edge_dir = 1;
            } else {             // Possible end of burst
#if IR_SAMSUNG
                if( (ir_time_since_last>430)&&(ir_time_since_last<470) ) {
#else
                if( (ir_time_since_last>880)&&(ir_time_since_last<920) ) {
#endif
                    ir_state = 1;
                    EICRA &= ~((1<<ISC21)|(1<<ISC20));
                    EICRA |= (1<<ISC21);
                    ir_edge_dir = 0;
                } else {
                    ir_receiver_reset();
                }
            }
            break;

        case 1:                  //Waiting for AFC gap
            if( (ir_time_since_last>430)&&(ir_time_since_last<470) ) {

                ir_state = 2;
                ir_bit = 0;
                ir_byte = 0;

                EICRA |= ((1<<ISC21)|(1<<ISC20));
                ir_edge_dir = 1;

            } else if( (ir_time_since_last>205)&&(ir_time_since_last<245) ) {
                ir_repeat = 1;
                process_poll(&ir_receiver_process);
                ir_receiver_reset();
            } else {
                ir_receiver_reset();
            }
            break;
        case 2:              //Waiting for bits
            if(ir_edge_dir) {
                if( ir_byte > 3) {
                    memcpy(ir_last_data, ir_data, 4);
                    process_poll(&ir_receiver_process);
                    ir_receiver_reset();
                } else if( (ir_time_since_last>50)&&(ir_time_since_last<70) ) {
                    EICRA &= ~((1<<ISC21)|(1<<ISC20));
                    EICRA |= (1<<ISC21);
                    ir_edge_dir = 0;
                } else {
                    ir_receiver_reset();
                }
            } else {
                if( (ir_time_since_last>40)&&(ir_time_since_last<60) ) {
                    ir_bit++;
                    if(ir_bit > 7) {
                        ir_bit = 0;
                        ir_byte++;
                    }
                    EICRA |= ((1<<ISC21)|(1<<ISC20));
                    ir_edge_dir = 1;
                } else if( (ir_time_since_last>150)&&(ir_time_since_last<190)) {
                    ir_data[ir_byte] |= (1<<ir_bit);
                    ir_bit++;
                    if(ir_bit > 7) {
                        ir_bit = 0;
                        ir_byte++;
                    }
                    EICRA |= ((1<<ISC21)|(1<<ISC20));
                    ir_edge_dir = 1;
                } else {
                    ir_receiver_reset();
                }
            }
            break;

        default:
            break;
    }

    EIMSK |= (1<<INT2 );
}

ISR(TIMER0_COMPA_vect) {
    ir_time++;
}

