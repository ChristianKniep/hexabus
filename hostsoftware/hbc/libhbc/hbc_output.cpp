#include "hba_output.hpp"

#include <libhbc/error.hpp>

using namespace hexabus;

void HBAOutput::operator()(std::ostream& ostr) {
  // TODO
  // - find highest state machine index
  //   - this will work differently later, when the machines are partitioned, but for now we assume that each state machine only controls one device
  // - go through all the state machines and translate them
  //   - states to states
  //   - if-conditions to conditions
  //     - this also needs more thinking!! (*)
  //   - write actions to actions
  //     - more thinking: What happens on multiple writes? (*)
  //
  // *) These should be done on graph level, along with the slicing/partitoning.


  // For now, just assume we only work on machine index 0 (single device, single state machine)
  // TODO once this works, extend.

  ostr << "# Auto-generated by Hexbaus Compiler" << std::endl; // TODO nicer looking message
  ostr << std::endl;

  ostr << "startstate init;" << std::endl;

  // iterate over vertices, find condition vertices and create condition blocks for them.
  graph_t::vertex_iterator vertexIt, vertexEnd;
  boost::tie(vertexIt, vertexEnd) = vertices((*_g));
  for (; vertexIt != vertexEnd; ++vertexIt){
    vertex_id_t vertexID = *vertexIt;
    vertex_t & vertex = (*_g)[vertexID];
    if (vertex.type == v_cond /* TODO */ && vertex.machine_id == 0) {
      try {
        condition_doc cond = boost::get<condition_doc>(vertex.contents);
        try {
          atomic_condition_doc at_cond = boost::get<atomic_condition_doc>(cond);

          // give the condition a name
          ostr << "condition cond_" << vertex.machine_id << "_" << vertex.vertex_id << " {" << std::endl;

          // find the device alias, print its IP address
          try {
            device_table::iterator d_it = _d->find(boost::get<std::string>(at_cond.geid.device_alias));
            if(d_it == _d->end()) {
              // TODO this is an error in the input file
              std::ostringstream oss;
              oss << "Device name not found: " << boost::get<std::string>(at_cond.geid.device_alias);
              throw HBAConversionErrorException(oss.str());
            }

            ostr << "  ip := " << d_it->second.ipv6_address << ";" << std::endl;

          } catch(boost::bad_get e) {
            // TODO this is an error in the input file
            std::ostringstream oss;
            oss << "Only literal device names (no placeholders) allowed in state machine definition!" << std::endl;
            throw HBAConversionErrorException(oss.str());
          }

          // find the endpoint name, print its IP address
          try {
            endpoint_table::iterator e_it = _e->find(boost::get<std::string>(at_cond.geid.endpoint_name));
            if(e_it == _e->end()) {
              // TODO this is an error in the input file
              std::ostringstream oss;
              oss << "Endpoint name not found: " << boost::get<std::string>(at_cond.geid.endpoint_name) << std::endl;
              throw HBAConversionErrorException(oss.str());
            }

            ostr << "  eid := " << e_it->second.eid << ";" << std::endl;

          } catch(boost::bad_get e) {
            // TODO this is an error in the input file
            std::ostringstream oss;
            oss << "Only literal endpoint names (no placeholders) allowed in state machine definition!" << std::endl;
            throw HBAConversionErrorException(oss.str());
          }

          // value comparison...
          ostr << "  value ";

          // comparison operator
          switch(at_cond.comp_op) {
            case STM_EQ:
              ostr << "==";
              break;
            case STM_LEQ:
              ostr << "<=";
              break;
            case STM_GEQ:
              ostr << ">=";
              break;
            case STM_LT:
              ostr << "<";
              break;
            case STM_GT:
              ostr << ">";
              break;
            case STM_NEQ:
              ostr << "!=";
              break;
            default:
              throw HBAConversionErrorException("operator not implemeted");
              break;
          }

          // constant
          try {
            ostr << " " << boost::get<std::string>(at_cond.constant) << ";" << std::endl;;
          } catch(boost::bad_get e) {
            // TODO this is an error in the input file
            std::ostringstream oss;
            oss << "Only literal constants (no placeholders) allowed in state machine definition!" << std::endl;
            throw HBAConversionErrorException(oss.str());
          }

          // closing bracket
          ostr << "}" << std::endl << std::endl;

        } catch(boost::bad_get e) {
          // TODO this is a not-implemented-yet error
          throw HBAConversionErrorException("Only atomic conditions implemented at the moment :(");
        }
      } catch(boost::bad_get e) {
        // TODO this is a hexabus-compiler-has-a-bug error
        std::ostringstream oss;
        oss << "Condition vertex does not contain condition data!" << std::endl;
        throw HBAConversionErrorException(oss.str());
      }
    }
  }
}

